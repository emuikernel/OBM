/******************************************************************************
 *
 *  (C)Copyright 2005 - 2011 Marvell. All Rights Reserved.
 *
 *  THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF MARVELL.
 *  The copyright notice above does not evidence any actual or intended
 *  publication of such source code.
 *  This Module contains Proprietary Information of Marvell and should be
 *  treated as Confidential.
 *  The information in this file is provided for the exclusive use of the
 *  licensees of Marvell.
 *  Such users have the right to use, modify, and incorporate this code into
 *  products for purposes authorized by the license agreement provided they
 *  include this notice and the associated copyright notice with any such
 *  product.
 *  The information in this file is provided "AS IS" without warranty.
 *
******************************************************************************/

#include "sdmmc_api.h"
#include "Errors.h"
#include "PlatformConfig.h"
#include "sdhc2.h"
#if SDIO
#include "sdio.h"
#endif

static SDMMC_Properties_T SDMMC_Prop;

/***********************************************************
*    UINT_T SDMMC_SHUTDOWN()
*    Description:
*			Shutsdown and cleans up after the SDMMC device
*    input:
*       	none
*    output:
*       	All the needed hardware should be un-initialized.
*    returns:
*     		WTPTP recognized errors
************************************************************/
UINT_T SDMMC_SHUTDOWN()
{
	UINT_T Retval = NoError;

	// Initialize Flash Properties
	P_SDMMC_Properties_T pSDMMCP = GetSDMMCProperties();

	// Is this even initialized?
	if (pSDMMCP->State == UNINITIALIZED)
			return Retval;

	// Shutdown
	pSDMMCP->Funcs.Shut_F();

	// Restore MMC GPIO's to their default settings
	DisableMMCSlots();

	pSDMMCP->State = UNINITIALIZED;
	return Retval;
}

/***********************************************************
*    UINT_T InitializeSDMMCDevice (P_FlashProperties_T pFlashP, UINT8_T* P_DefaultPartitionNum)
*    Description:
*       	Initializes the SDMMC port on the platform and all
*       	of the other necessary hardware needed for SDMMC
*       	reading, writing and erasing.
*    input:
*      	 none
*    output:
*       	All the needed hardware should be initialized.
*    returns:
*      	WTPTP recognized errors
************************************************************/
UINT_T InitializeSDMMCDevice(UINT8_T FlashNum, UINT8_T* P_DefaultPartitionNum)
{
	UINT_T switchReturn;
	UINT_T baseAddress;			// base address of the Host Controller and interface
	UINT_T interruptMask;		// the interrupt ID generated by the selected SDMMC Host Controller
	UINT_T fusePartitionNumber;
	FUSE_SET Fuses;
	P_SDMMC_Properties_T pSDMMCP;
	P_FlashProperties_T pFlashP;
	CONTROLLER_TYPE controller;
	XLLP_STATUS_T Status = NoError;

	// Get platform fuses to see if we are allowed to enable MMC
	GetPlatformFuses(NULL, &Fuses);

	// Are we allowed to enable SD/MMC
	if (Fuses.bits.MMCDisable)
		return SDMMCNotFound;

	// Setup pins and determine controller.
	controller = ConfigureMMC(FlashNum, &baseAddress, &interruptMask, &fusePartitionNumber);

	// Initialize Flash Properties
	pSDMMCP = GetSDMMCProperties();

	// Clean it out
	memset (pSDMMCP, 0, sizeof(SDMMC_Prop));

	pSDMMCP->ControllerType = controller;
	pFlashP = GetFlashProperties();

	//define functions
	pFlashP->ReadFromFlash = &SDMMC_READ;
	pFlashP->WriteToFlash = &SDMMC_WRITE;
	pFlashP->EraseFlash =  &SDMMC_ERASE;
	pFlashP->FinalizeFlash = &SDMMC_SHUTDOWN;
	pFlashP->TimFlashAddress = TIMOffset_SDMMC;
	pFlashP->FlashType = SDMMC_FLASH;
	pFlashP->ChangePartition = &SDMMC_SETPARTITION;
	pFlashP->GenerateFBBT = NULL;
	pFlashP->ValidateFlashPartitions = &SDMMC_ValidateFlashPartitions;
	pFlashP->CreateFlashPartitions = &SDMMC_CreateFlashPartitions;
	pSDMMCP->pFlashP = pFlashP;

	pFlashP->BackupTimFlashAddress = BackupTIMOffset_SDMMC;
	pSDMMCP->StrictErrorCheck = 0;	// Relax error checking during card init. Not all cards are strictly compliant.

	if (pSDMMCP->ControllerType == MMCNOTENABLED)
	{
		return SDMMCNotFound;
	}
	else
	{
#if SDIO
        if(FlashNum == SDIO_P)
        {
            pSDMMCP->Funcs.Write_F = &MM4_SDIO_WriteBlocks;
            pSDMMCP->Funcs.Read_F = &MM4_SDIO_ReadBlocks;
            pSDMMCP->Funcs.Shut_F = &MM4_SDIO_CardShutdown;
            pSDMMCP->Funcs.Init_F = &MM4_SDIO_CardInit;
            pSDMMCP->Funcs.Erase_F = NULL;
            pSDMMCP->Funcs.SwitchPartition_F = NULL;
            pFlashP->StreamingFlash = FALSE;
        }
        else
#endif
        {
            pSDMMCP->Funcs.Write_F = &MM4_WriteBlocks;
            pSDMMCP->Funcs.Erase_F = &MM4_EraseBlocks;
            pSDMMCP->Funcs.Shut_F = &MM4_CardShutdown;
            pSDMMCP->Funcs.SwitchPartition_F = &MM4SwitchPartition;
#if BOOTROM
            if ((FlashNum == SDMMC_FLASH_OPT4_P) || (FlashNum == SDMMC_FLASH_OPT3_P))
            {
                pSDMMCP->Funcs.Init_F = &MM4_MMCAlternateBootMode;
                pSDMMCP->Funcs.Read_F = &MM4_MMCAlternateBootModeReadBlocks;
                pFlashP->StreamingFlash = TRUE;
            }
            else
            {
                pSDMMCP->Funcs.Init_F = &MM4_CardInit;
                pSDMMCP->Funcs.Read_F = &MM4_ReadBlocks;
                pFlashP->StreamingFlash = FALSE;
            }
#else
            
            pSDMMCP->Funcs.Init_F = &MM4_CardInit;
            pSDMMCP->Funcs.Read_F = &MM4_ReadBlocks;
            pFlashP->StreamingFlash = FALSE;    
#endif
        }
	}

	// Find a card in the desired controller
	Status = pSDMMCP->Funcs.Init_F(baseAddress, interruptMask);
	if (Status != NoError)
	{
 		SDMMC_SHUTDOWN();
		return Status;
	}

#if BOOTROM
    if ((FlashNum == SDMMC_FLASH_OPT4_P) || (FlashNum == SDMMC_FLASH_OPT3_P))		// No further processing is needed for alternate boot mode method.
		return Status;
#endif

    #if SDIO
    if(FlashNum == SDIO_P)
        return Status;
    #endif
	// Does this platform care what partition to boot from? If not allow default partition if it can't switch.
	if (fusePartitionNumber == MMC_SD_USER_PARTITION)
	{
		*P_DefaultPartitionNum = MMC_SD_USER_PARTITION; 			// Default value
	  	// try to set to the Boot partition
		switchReturn = pSDMMCP->Funcs.SwitchPartition_F(MMC_SD_BOOT_PARTITION);
		if (switchReturn == NoError)
			*P_DefaultPartitionNum = MMC_SD_BOOT_PARTITION;		// Return back Boot Partition
	}
	else	// Must boot from selected partition or error.
	{
		switchReturn = pSDMMCP->Funcs.SwitchPartition_F(fusePartitionNumber);
		if (switchReturn != NoError)
			return SDMMC_SWITCH_ERROR;
		else
			*P_DefaultPartitionNum = fusePartitionNumber;
	}

    return Status;
}

/***********************************************************
*    SDMMC_READ()
*	 Description:
*		This function will read as many bytes as specified from FlashOffset to Local
*		Buffer. The flash driver must have been previously initailized using
*		InitializeSDMMCDriver. If the function encounters an error it will not
* 		re-attempt the operation.
*    input:
*		FlashOffset - The source address on the flash where data will come from
*			specified as a byte value. Must be 32 bits aligned
*		Local Buffer - Local address where data will be read in to.
*		Size - Specifies number of bytes to read - 32 bits aligned
*    output:
*       Desired Values are read
*    returns:
*       WTPTP recognized errors
************************************************************/

UINT_T SDMMC_READ (UINT_T FlashOffset, UINT_T LocalBuffer, UINT_T Size)
{
	UINT_T argument;
	UINT_T Retval = NoError;
    UINT_T flags = NO_FLAGS;

	// We will divide the original data we want to read from flash into big chunks.
	// BLOCK_COUNT register of the controller can support at most 65535 blocks in one read operation.
	// Also note that the block size is 512 bytes.
	// As a result, the biggest chunk supported is 65535*512 = 33553920 bytes!
	UINT32_T read_chunk = 33553920;
    
	UINT_T remaining_Size = Size;				// Remaining size to read from flash. Initially equal to the original size.
	UINT_T current_read_Size = 0;				// This is the size for the current read in the main loop.
	UINT_T remaining_FlashOffset = FlashOffset;	// Offset in Flash for the remaining data. Initially equal to original flash offset.

	// Initialize Flash Properties
	P_SDMMC_Properties_T pSDMMCP = GetSDMMCProperties();
    
    #if SDIO
    // we can only send max 512 blocks with SDIO
    read_chunk = 512 * SDIO_BLOCK_SIZE;
    #endif

	// Make sure State is correct
	if (pSDMMCP->State != READY)
		return SDMMCDeviceNotReadyError;

	// Check if Start Address and Size are word aligned
	if ( ((Size % 4) !=0) || ((FlashOffset % 4) !=0) || ((LocalBuffer % 4) !=0))
		return SDMMC_ADDR_MISALIGN_ERROR;

	// We divide the initial size that will be read from the flash into chunks whose size is determined by read_chunk variable.
	// This while loop iterates through each chunk and and calls the READ FLASH function for each.
	while( remaining_Size > 0 )
	{
		// If the remaining size is larger than 32 MB, then we keep reading 32 MB.
		// Otherwise, we only read the remaining number of bytes.
		if ( remaining_Size > read_chunk)
			current_read_Size = read_chunk;
		else
			current_read_Size = remaining_Size;

		// Does the start/end addresses align on Block Boundries? Probably not, record discard bytes
		pSDMMCP->Trans.CardAddress = remaining_FlashOffset;
		pSDMMCP->Trans.StartDiscardWords = remaining_FlashOffset % pSDMMCP->ReadBlockSize;

		if (((remaining_FlashOffset + current_read_Size) % pSDMMCP->ReadBlockSize) == 0)
			pSDMMCP->Trans.EndDiscardWords = 0;
		else
			pSDMMCP->Trans.EndDiscardWords = pSDMMCP->ReadBlockSize - ((remaining_FlashOffset + current_read_Size) % pSDMMCP->ReadBlockSize);

		pSDMMCP->Trans.NumBlocks = (pSDMMCP->Trans.EndDiscardWords + pSDMMCP->Trans.StartDiscardWords + current_read_Size) / pSDMMCP->ReadBlockSize;
		pSDMMCP->Trans.TransWordSize = pSDMMCP->Trans.NumBlocks * pSDMMCP->ReadBlockSize / 4; 		// Total Transfer Size including pre and post, in words

		// Convert to # of words
		pSDMMCP->Trans.StartDiscardWords /= 4;
		pSDMMCP->Trans.EndDiscardWords /= 4;
		pSDMMCP->Trans.LocalAddr = LocalBuffer;
		pSDMMCP->Trans.WordIndex = 0;									// Stores Index of Current read position

		// Kick off the Read
		Retval = pSDMMCP->Funcs.Read_F();
		if (pSDMMCP->State == FAULT){
			Retval = (SDMMCGetCardErrorState(pSDMMCP));
			break;
		}

		// Adjust the LocalBuffer address, FlashOffset, and the remaining_size which are used in the while loop.
		LocalBuffer += current_read_Size;
		remaining_FlashOffset += current_read_Size;
		remaining_Size -= current_read_Size;
	}	// End while

	pSDMMCP->State = READY;

	return Retval;
}

/***********************************************************
*    SDMMC_WRITE()
*    input:
*	 Description:
*		This function will write as many bytes as specified from LocalBuffer to Flash
*		Offset. The flash driver must have been previously initialized using
*		InitializeSDMMCDriver. The relavent addresses must have been previously erased.
* 		If the function encounters an error it will not
* 		re-attempt the operation.
*    Inputs:
*	   FlashOffset - The source address on the flash where data will be written to
*			specified as a byte value. Must be 32 bits aligned
*		LocalBuffer - Local address where data will be copied from.
*		Size - Specifies number of bytes to write - 32 bits aligned
*    output:
*       Desired Values are written to flash
*    returns:
*       WTPTP recognized errors
************************************************************/
UINT_T SDMMC_WRITE (UINT_T FlashOffset, UINT_T LocalBuffer, UINT_T Size)
{
	UINT_T argument;
	UINT_T Retval = NoError;
    UINT_T flags = NO_FLAGS;

	// We will divide the original data we want to write to flash into big chunks.
	// BLOCK_COUNT register of the controller can support at most 65535 blocks in one write operation.
	// Also note that the block size is 512 bytes.
	// As a result, the biggest chunk supported is 65535*512 = 33553920 bytes!
	UINT32_T write_chunk = 33553920;

	UINT_T remaining_Size = Size;				// Remaining size to write to flash. Initially equal to the original size.
	UINT_T current_write_Size = 0;				// This is the size for the current write in the main loop.
	UINT_T remaining_FlashOffset = FlashOffset;	// Offset in Flash for the remaining data. Initially equal to original flash offset.

	// Initialize Flash Properties
	P_SDMMC_Properties_T pSDMMCP = GetSDMMCProperties();
    
    #if SDIO
    // we can only send max 512 blocks with SDIO
    write_chunk = 512 * SDIO_BLOCK_SIZE;
    #endif

	// Make sure State is correct
	if (pSDMMCP->State != READY)
		return SDMMCDeviceNotReadyError;

	// Check if Start Address and Size are word aligned
	if ( ((Size % 4) !=0) || ((FlashOffset % 4) !=0) || ((LocalBuffer % 4) !=0))
		return SDMMC_ADDR_MISALIGN_ERROR;

	// We divide the initial size that will be written to the flash into chunks whose size is determined by write_chunk variable.
	// This while loop iterates through each chunk and and calls the WRITE FLASH function for each.
	while( remaining_Size > 0 )
	{
		// If the remaining size is larger than 32 MB, then we keep writing 32 MB.
		// Otherwise, we only write the remaining number of bytes.
		if ( remaining_Size > write_chunk)
			current_write_Size = write_chunk;
		else
			current_write_Size = remaining_Size;

		// Does the start/end addresses align on Block Boundries? Probably not, record discard bytes
		pSDMMCP->Trans.CardAddress = remaining_FlashOffset;
		pSDMMCP->Trans.StartDiscardWords = remaining_FlashOffset % pSDMMCP->WriteBlockSize;

		if (((remaining_FlashOffset + current_write_Size) % pSDMMCP->WriteBlockSize) == 0)
			pSDMMCP->Trans.EndDiscardWords = 0;
		else
			pSDMMCP->Trans.EndDiscardWords = pSDMMCP->WriteBlockSize - ((remaining_FlashOffset + current_write_Size) % pSDMMCP->WriteBlockSize);

		pSDMMCP->Trans.NumBlocks = (pSDMMCP->Trans.EndDiscardWords + pSDMMCP->Trans.StartDiscardWords + current_write_Size) / pSDMMCP->WriteBlockSize;
		pSDMMCP->Trans.TransWordSize = pSDMMCP->Trans.NumBlocks * pSDMMCP->WriteBlockSize / 4; 		// Total Transfer Size including pre and post, in words

		// Convert to # of words
		pSDMMCP->Trans.StartDiscardWords /= 4;
		pSDMMCP->Trans.EndDiscardWords /= 4;
		pSDMMCP->Trans.LocalAddr = LocalBuffer;
		pSDMMCP->Trans.WordIndex = 0;									// Stores Index of Current write position

		// Kick off the Write
		Retval = pSDMMCP->Funcs.Write_F();
		if (pSDMMCP->State == FAULT){
			Retval = (SDMMCGetCardErrorState(pSDMMCP));
			break;
		}

		// Adjust the LocalBuffer address, FlashOffset, and the remaining_size which are used in the while loop.
		LocalBuffer += current_write_Size;
		remaining_FlashOffset += current_write_Size;
		remaining_Size -= current_write_Size;

	}	// End while

	pSDMMCP->State = READY;

	return Retval;
}

/***********************************************************
*    SDMMC_ERASE()
*	 Description:
*		This function will erase bytes that fall on erase group boundries. If the starting
*		address and size do not fall on erase group boundries, they will be rounded up to do so.
*    input:
*       FlashOffset - The source address on the flash where data will begin to be erased
*		Size - Specifies number of bytes to erase. Note that flash technology dictates
* 			flash be erased on erase group granularity
*    output:
*		Desired blocks are erased from flash
*    returns:
*       WTPTP recognized errors
************************************************************/
UINT_T SDMMC_ERASE (UINT_T FlashOffset, UINT_T Size)
{
	UINT_T Retval = NoError;

	// Initialize Flash Properties
	P_SDMMC_Properties_T pSDMMCP = GetSDMMCProperties();

	// Make sure State is correct
	if (pSDMMCP->State != READY)
		return SDMMCDeviceNotReadyError;

	// Set the correct state
	pSDMMCP->State = ERASE;
	pSDMMCP->Trans.CardAddress = FlashOffset;
	pSDMMCP->Trans.TransWordSize = Size/4;

	// Kick off the read
	Retval = pSDMMCP->Funcs.Erase_F();

    //send CMD13 to check the status of the card
	if (pSDMMCP->State == FAULT)
		Retval = (SDMMCGetCardErrorState(pSDMMCP));		   // TBD s/w reset?
	pSDMMCP->State = READY;

	return Retval;
}

/***********************************************************
*    SDMMC_SETPARTITION()
*	 Description:
*		This function will call into the MMC device to change to the specified partition
*    input:
*       PartitionNum - Partition Number to set in the device
*    output:
*		none
*    returns:
*       WTPTP recognized errors
************************************************************/
void SDMMC_SETPARTITION (UINT_T PartitionNum)
{
	UINT_T Retval = NoError;

	// Initialize Flash Properties
	P_SDMMC_Properties_T pSDMMCP = GetSDMMCProperties();
	// Make sure State is correct
	if (pSDMMCP->State != READY)
		return;

	// If we can't switch partitions we continue don't flag an error
	Retval = pSDMMCP->Funcs.SwitchPartition_F(PartitionNum);
	pSDMMCP->State = READY;

	return;
}

/***********************************************************************************
************************************************************************************
Below routines are not Application interface but common between driver variants
/***********************************************************************************
************************************************************************************


/****************************************************************
*    GetSDMMCProperties
*		Rerturn SDMMC Properties structure
*    Input:
*		none
*    Output:
*		none
*    Returns:
*       none
*****************************************************************/
P_SDMMC_Properties_T GetSDMMCProperties(void)
{
	return &SDMMC_Prop;
}


/****************************************************************
*   SDMMC_ISR
*      	Interrupt Service Routine for SDMMC controller
* 		Provides switch control to appropriate controller's low level ISR
*   Input:
*	   none
*   Output:
*      none
*   Returns:
*      none
*****************************************************************/

void SDMMC_ISR()
{
	// Retreive SDMMC context
	P_SDMMC_Properties_T pSDMMCP = GetSDMMCProperties();

	MM4_ISR(pSDMMCP);

	return;
}


/****************************************************************
*   SDMMCGetCardErrorState
*
*   Input:
*		pSDMMCP - pointer to the current context
*   Output:
*      none
*   Returns:
*      Converts the error code read in from the card as R1 value in to
* 	   a WTPTP recognized return value
*****************************************************************/
UINT_T SDMMCGetCardErrorState(P_SDMMC_Properties_T pSDMMCP)
{
	UINT_T					RetVal   = SDMMC_GENERAL_ERROR;
//	P_MM4_SDMMC_CONTEXT_T	pContext = (P_MM4_SDMMC_CONTEXT_T) pSDMMCP->pContext;

	if ((pSDMMCP->CardReponse.R1_RESP & R1_SWITCH_ERROR) == R1_SWITCH_ERROR)
		RetVal = SDMMC_SWITCH_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_ERASE_RESET_ERROR) == R1_ERASE_RESET_ERROR)
		RetVal = SDMMC_ERASE_RESET_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_CIDCSD_OVERWRITE_ERROR) == R1_CIDCSD_OVERWRITE_ERROR)
		RetVal = SDMMC_CIDCSD_OVERWRITE_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_OVERRUN_ERROR) == R1_OVERRUN_ERROR)
		RetVal = SDMMC_OVERRUN_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_UNDERUN_ERROR) == R1_UNDERUN_ERROR)
		RetVal = SDMMC_UNDERUN_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_CC_ERROR) == R1_CC_ERROR)
		RetVal = SDMMC_CC_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_ECC_ERROR) == R1_ECC_ERROR)
		RetVal = SDMMC_ECC_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_ILL_CMD_ERROR) == R1_ILL_CMD_ERROR)
		RetVal = SDMMC_ILL_CMD_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_COM_CRC_ERROR) == R1_COM_CRC_ERROR)
		RetVal = SDMMC_COM_CRC_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_LOCK_ULOCK_ERRROR) == R1_LOCK_ULOCK_ERRROR)
		RetVal = SDMMC_LOCK_ULOCK_ERRROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_LOCK_ERROR) == R1_LOCK_ERROR)
		RetVal = SDMMC_LOCK_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_WP_ERROR) == R1_WP_ERROR)
		RetVal = SDMMC_WP_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_ERASE_PARAM_ERROR) == R1_ERASE_PARAM_ERROR)
		RetVal = SDMMC_ERASE_PARAM_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_ERASE_SEQ_ERROR) == R1_ERASE_SEQ_ERROR)
		RetVal = SDMMC_ERASE_SEQ_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_BLK_LEN_ERROR) == R1_BLK_LEN_ERROR)
		RetVal = SDMMC_BLK_LEN_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_ADDR_MISALIGN_ERROR) == R1_ADDR_MISALIGN_ERROR)
		RetVal = SDMMC_ADDR_MISALIGN_ERROR;
	else if ((pSDMMCP->CardReponse.R1_RESP & R1_ADDR_RANGE_ERROR) == R1_ADDR_RANGE_ERROR)
		RetVal = SDMMC_ADDR_RANGE_ERROR;

	return RetVal;
}


//////////////////////////////////////////////////////////////////////
// This is the partition validation function for the SDMMC flashes.
//
// Inputs: The downloaded PT and the Flash Boot Type.
// Outputs: Returns NoError if partitions match, and an Error Code otherwise.
//
// It mainly compares the partition information in the downloaded PT
// with the partitions that are already on the device. If NoError is
// returned, this means that the partitions match. Otherwise, an Error
// Code means that the partitions do NOT match.
//////////////////////////////////////////////////////////////////////
UINT_T SDMMC_ValidateFlashPartitions (P_PartitionTable_T PartitionTable)
{
	UINT_T Retval = NoError;

	// MBR TO DO:
	// This function needs to be filled in.

	return Retval;
}


//////////////////////////////////////////////////////////////////////
// This is the partition creation function for the SDMMC flashes.
//
// Inputs: The downloaded PT and the Flash Boot Type.
// Outputs: Returns NoError if partitions are created successfully, and
//          an Error Code otherwise.
//
// It mainly configures the the partitions on the Flash device using
// the partition information in the downloaded PT. If NoError is
// returned, this means that the partitions are created successfully.
// Otherwise, an Error Code is returned.
//////////////////////////////////////////////////////////////////////
UINT_T SDMMC_CreateFlashPartitions (P_PartitionTable_T PartitionTable)
{
	UINT_T Retval = NoError;

	// MBR TO DO:
	// This function needs to be filled in.

	return Retval;
}
